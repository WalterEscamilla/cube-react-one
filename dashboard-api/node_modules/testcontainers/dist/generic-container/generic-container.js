"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericContainer = void 0;
const archiver_1 = __importDefault(require("archiver"));
const logger_1 = require("../logger");
const port_binder_1 = require("../port-binder");
const port_check_1 = require("../port-check");
const pull_policy_1 = require("../pull-policy");
const reaper_1 = require("../reaper");
const docker_image_name_1 = require("../docker-image-name");
const wait_strategy_1 = require("../wait-strategy");
const port_forwarder_1 = require("../port-forwarder");
const registry_auth_locator_1 = require("../registry-auth-locator");
const pull_image_1 = require("../docker/functions/image/pull-image");
const create_container_1 = require("../docker/functions/container/create-container");
const connect_network_1 = require("../docker/functions/network/connect-network");
const docker_host_1 = require("../docker/docker-host");
const inspect_container_1 = require("../docker/functions/container/inspect-container");
const start_container_1 = require("../docker/functions/container/start-container");
const container_logs_1 = require("../docker/functions/container/container-logs");
const stop_container_1 = require("../docker/functions/container/stop-container");
const remove_container_1 = require("../docker/functions/container/remove-container");
const put_container_archive_1 = require("../docker/functions/container/put-container-archive");
const generic_container_builder_1 = require("./generic-container-builder");
const started_generic_container_1 = require("./started-generic-container");
class GenericContainer {
    constructor(image) {
        this.image = image;
        this.env = {};
        this.networkAliases = [];
        this.ports = [];
        this.cmd = [];
        this.bindMounts = [];
        this.tmpFs = {};
        this.startupTimeout = 60000;
        this.useDefaultLogDriver = false;
        this.privilegedMode = false;
        this.pullPolicy = new pull_policy_1.DefaultPullPolicy();
        this.extraHosts = [];
        this.imageName = docker_image_name_1.DockerImageName.fromString(image);
    }
    static fromDockerfile(context, dockerfileName = "Dockerfile") {
        return new generic_container_builder_1.GenericContainerBuilder(context, dockerfileName);
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield pull_image_1.pullImage({
                imageName: this.imageName,
                force: this.pullPolicy.shouldPull(),
                authConfig: yield registry_auth_locator_1.getAuthConfig(this.imageName.registry),
            });
            const boundPorts = yield new port_binder_1.PortBinder().bind(this.ports);
            if (!this.imageName.isReaper()) {
                yield reaper_1.ReaperInstance.getInstance();
            }
            if (this.preCreate) {
                yield this.preCreate(boundPorts);
            }
            if (!this.imageName.isHelperContainer() && port_forwarder_1.PortForwarderInstance.isRunning()) {
                const portForwarder = yield port_forwarder_1.PortForwarderInstance.getInstance();
                this.extraHosts.push({ host: "host.testcontainers.internal", ipAddress: portForwarder.getIpAddress() });
            }
            const container = yield create_container_1.createContainer({
                imageName: this.imageName,
                env: this.env,
                cmd: this.cmd,
                bindMounts: this.bindMounts,
                tmpFs: this.tmpFs,
                boundPorts,
                name: this.name,
                networkMode: this.networkAliases.length > 0 ? undefined : this.networkMode,
                healthCheck: this.healthCheck,
                useDefaultLogDriver: this.useDefaultLogDriver,
                privilegedMode: this.privilegedMode,
                autoRemove: this.imageName.isReaper(),
                extraHosts: this.extraHosts,
                ipcMode: this.ipcMode,
                user: this.user,
            });
            if (!this.imageName.isHelperContainer() && port_forwarder_1.PortForwarderInstance.isRunning()) {
                const portForwarder = yield port_forwarder_1.PortForwarderInstance.getInstance();
                const portForwarderNetworkId = portForwarder.getNetworkId();
                const excludedNetworks = [portForwarderNetworkId, "none", "host"];
                if (!this.networkMode || !excludedNetworks.includes(this.networkMode)) {
                    yield connect_network_1.connectNetwork({ containerId: container.id, networkId: portForwarderNetworkId, networkAliases: [] });
                }
            }
            if (this.networkMode && this.networkAliases.length > 0) {
                yield connect_network_1.connectNetwork({
                    containerId: container.id,
                    networkId: this.networkMode,
                    networkAliases: this.networkAliases,
                });
            }
            if (this.tarToCopy) {
                yield this.tarToCopy.finalize();
                yield put_container_archive_1.putContainerArchive({ container, stream: this.tarToCopy, containerPath: "/" });
            }
            logger_1.log.info(`Starting container ${this.imageName} with ID: ${container.id}`);
            yield start_container_1.startContainer(container);
            (yield container_logs_1.containerLogs(container))
                .on("data", (data) => logger_1.containerLog.trace(`${container.id}: ${data.trim()}`))
                .on("err", (data) => logger_1.containerLog.error(`${container.id}: ${data.trim()}`));
            const inspectResult = yield inspect_container_1.inspectContainer(container);
            yield this.waitForContainer(container, boundPorts);
            return new started_generic_container_1.StartedGenericContainer(container, yield docker_host_1.dockerHost, inspectResult, boundPorts, inspectResult.name);
        });
    }
    withCmd(cmd) {
        this.cmd = cmd;
        return this;
    }
    withName(name) {
        this.name = name;
        return this;
    }
    withEnv(key, value) {
        this.env[key] = value;
        return this;
    }
    withTmpFs(tmpFs) {
        this.tmpFs = tmpFs;
        return this;
    }
    withNetworkMode(networkMode) {
        this.networkMode = networkMode;
        return this;
    }
    withNetworkAliases(...networkAliases) {
        this.networkAliases = networkAliases;
        return this;
    }
    withExposedPorts(...ports) {
        this.ports = ports;
        return this;
    }
    withBindMount(source, target, bindMode = "rw") {
        this.bindMounts.push({ source, target, bindMode });
        return this;
    }
    withHealthCheck(healthCheck) {
        this.healthCheck = healthCheck;
        return this;
    }
    withStartupTimeout(startupTimeout) {
        this.startupTimeout = startupTimeout;
        return this;
    }
    withWaitStrategy(waitStrategy) {
        this.waitStrategy = waitStrategy;
        return this;
    }
    withDefaultLogDriver() {
        this.useDefaultLogDriver = true;
        return this;
    }
    withPrivilegedMode() {
        this.privilegedMode = true;
        return this;
    }
    withUser(user) {
        this.user = user;
        return this;
    }
    withPullPolicy(pullPolicy) {
        this.pullPolicy = pullPolicy;
        return this;
    }
    withIpcMode(ipcMode) {
        this.ipcMode = ipcMode;
        return this;
    }
    withCopyFileToContainer(sourcePath, containerPath) {
        this.getTarToCopy().file(sourcePath, { name: containerPath });
        return this;
    }
    withCopyContentToContainer(content, containerPath) {
        this.getTarToCopy().append(content, { name: containerPath });
        return this;
    }
    getTarToCopy() {
        if (!this.tarToCopy) {
            this.tarToCopy = archiver_1.default("tar");
        }
        return this.tarToCopy;
    }
    waitForContainer(container, boundPorts) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.debug(`Waiting for container to be ready: ${container.id}`);
            const waitStrategy = this.getWaitStrategy(yield docker_host_1.dockerHost, container);
            try {
                yield waitStrategy.withStartupTimeout(this.startupTimeout).waitUntilReady(container, boundPorts);
                logger_1.log.info("Container is ready");
            }
            catch (err) {
                logger_1.log.error(`Container failed to be ready: ${err}`);
                try {
                    yield stop_container_1.stopContainer(container, { timeout: 0 });
                    yield remove_container_1.removeContainer(container, { removeVolumes: true });
                }
                catch (stopErr) {
                    logger_1.log.error(`Failed to stop container after it failed to be ready: ${stopErr}`);
                }
                throw err;
            }
        });
    }
    getWaitStrategy(host, container) {
        if (this.waitStrategy) {
            return this.waitStrategy;
        }
        const hostPortCheck = new port_check_1.HostPortCheck(host);
        const internalPortCheck = new port_check_1.InternalPortCheck(container);
        return new wait_strategy_1.HostPortWaitStrategy(hostPortCheck, internalPortCheck);
    }
}
exports.GenericContainer = GenericContainer;
