"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartedGenericContainer = void 0;
const logger_1 = require("../logger");
const remove_container_1 = require("../docker/functions/container/remove-container");
const exec_container_1 = require("../docker/functions/container/exec-container");
const container_logs_1 = require("../docker/functions/container/container-logs");
const stopped_generic_container_1 = require("./stopped-generic-container");
const stop_container_1 = require("../docker/functions/container/stop-container");
class StartedGenericContainer {
    constructor(container, host, inspectResult, boundPorts, name) {
        this.container = container;
        this.host = host;
        this.inspectResult = inspectResult;
        this.boundPorts = boundPorts;
        this.name = name;
    }
    stop(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stopContainer(options);
        });
    }
    stopContainer(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.log.info(`Stopping container with ID: ${this.container.id}`);
            const resolvedOptions = Object.assign({ timeout: 0, removeVolumes: true }, options);
            yield stop_container_1.stopContainer(this.container, { timeout: resolvedOptions.timeout });
            yield remove_container_1.removeContainer(this.container, { removeVolumes: resolvedOptions.removeVolumes });
            return new stopped_generic_container_1.StoppedGenericContainer();
        });
    }
    getHost() {
        return this.host;
    }
    getMappedPort(port) {
        return this.boundPorts.getBinding(port);
    }
    getId() {
        return this.container.id;
    }
    getName() {
        return this.name;
    }
    getNetworkNames() {
        return Object.keys(this.inspectResult.networkSettings);
    }
    getNetworkId(networkName) {
        return this.inspectResult.networkSettings[networkName].networkId;
    }
    getIpAddress(networkName) {
        return this.inspectResult.networkSettings[networkName].ipAddress;
    }
    exec(command) {
        return exec_container_1.execContainer(this.container, command);
    }
    logs() {
        return container_logs_1.containerLogs(this.container);
    }
}
exports.StartedGenericContainer = StartedGenericContainer;
