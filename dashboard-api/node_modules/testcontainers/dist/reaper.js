"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReaperInstance = void 0;
const net_1 = require("net");
const logger_1 = require("./logger");
const generic_container_1 = require("./generic-container/generic-container");
const session_id_1 = require("./docker/session-id");
const docker_host_1 = require("./docker/docker-host");
const images_1 = require("./images");
class RealReaper {
    constructor(sessionId, container, socket) {
        this.sessionId = sessionId;
        this.container = container;
        this.socket = socket;
    }
    addProject(projectName) {
        this.socket.write(`label=com.docker.compose.project=${projectName}\r\n`);
    }
    getContainerId() {
        return this.container.getId();
    }
    stop() {
        this.socket.end();
    }
}
class DisabledReaper {
    addProject() {
        // noop
    }
    stop() {
        // noop
    }
    getContainerId() {
        return "";
    }
}
class ReaperInstance {
    static getInstance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.instance) {
                if (this.isEnabled()) {
                    this.instance = this.createRealInstance();
                }
                else {
                    this.instance = this.createDisabledInstance();
                }
            }
            return this.instance;
        });
    }
    static stopInstance() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.instance) {
                const reaper = yield this.instance;
                reaper.stop();
                this.instance = undefined;
            }
        });
    }
    static isEnabled() {
        return process.env.TESTCONTAINERS_RYUK_DISABLED !== "true";
    }
    static createDisabledInstance() {
        logger_1.log.debug(`Not creating new Reaper for session: ${session_id_1.sessionId}`);
        return Promise.resolve(new DisabledReaper());
    }
    static createRealInstance() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const dockerSocket = (_a = process.env["TESTCONTAINERS_DOCKER_SOCKET_OVERRIDE"]) !== null && _a !== void 0 ? _a : "/var/run/docker.sock";
            logger_1.log.debug(`Creating new Reaper for session: ${session_id_1.sessionId}`);
            const container = yield new generic_container_1.GenericContainer(images_1.REAPER_IMAGE)
                .withName(`testcontainers-ryuk-${session_id_1.sessionId}`)
                .withExposedPorts(8080)
                .withBindMount(dockerSocket, "/var/run/docker.sock")
                .withPrivilegedMode()
                .start();
            const host = yield docker_host_1.dockerHost;
            const port = container.getMappedPort(8080);
            logger_1.log.debug(`Connecting to Reaper ${container.getId()} on ${host}:${port}`);
            const socket = new net_1.Socket();
            socket.unref();
            socket
                .on("timeout", () => logger_1.log.error(`Reaper ${container.getId()} socket timed out`))
                .on("error", (err) => logger_1.log.error(`Reaper ${container.getId()} socket error: ${err}`))
                .on("close", (hadError) => {
                if (hadError) {
                    logger_1.log.error(`Connection to Reaper ${container.getId()} closed with error`);
                }
                else {
                    logger_1.log.warn(`Connection to Reaper ${container.getId()} closed`);
                }
            });
            return yield new Promise((resolve) => {
                socket.connect(port, host, () => {
                    logger_1.log.debug(`Connected to Reaper ${container.getId()}`);
                    socket.write(`label=org.testcontainers.session-id=${session_id_1.sessionId}\r\n`);
                    const reaper = new RealReaper(session_id_1.sessionId, container, socket);
                    resolve(reaper);
                });
            });
        });
    }
}
exports.ReaperInstance = ReaperInstance;
