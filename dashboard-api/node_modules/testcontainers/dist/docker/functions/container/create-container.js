"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createContainer = void 0;
const logger_1 = require("../../../logger");
const dockerode_1 = require("../../dockerode");
const create_labels_1 = require("../create-labels");
const createContainer = (options) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        logger_1.log.info(`Creating container for image: ${options.imageName}`);
        return yield dockerode_1.dockerode.createContainer({
            name: options.name,
            User: options.user,
            Image: options.imageName.toString(),
            Env: getEnv(options.env),
            ExposedPorts: getExposedPorts(options.boundPorts),
            Cmd: options.cmd,
            Labels: create_labels_1.createLabels(options.imageName),
            // @ts-ignore
            Healthcheck: getHealthCheck(options.healthCheck),
            HostConfig: {
                IpcMode: options.ipcMode,
                ExtraHosts: getExtraHosts(options.extraHosts),
                AutoRemove: options.autoRemove,
                NetworkMode: options.networkMode,
                PortBindings: getPortBindings(options.boundPorts),
                Binds: getBindMounts(options.bindMounts),
                Tmpfs: options.tmpFs,
                LogConfig: getLogConfig(options.useDefaultLogDriver),
                Privileged: options.privilegedMode,
            },
        });
    }
    catch (err) {
        logger_1.log.error(`Failed to create container for image ${options.imageName}: ${err}`);
        throw err;
    }
});
exports.createContainer = createContainer;
const getEnv = (env) => Object.entries(env).reduce((dockerodeEnvironment, [key, value]) => [...dockerodeEnvironment, `${key}=${value}`], []);
const getExposedPorts = (boundPorts) => {
    const dockerodeExposedPorts = {};
    for (const [internalPort] of boundPorts.iterator()) {
        dockerodeExposedPorts[internalPort.toString()] = {};
    }
    return dockerodeExposedPorts;
};
const getExtraHosts = (extraHosts) => {
    return extraHosts.map((extraHost) => `${extraHost.host}:${extraHost.ipAddress}`);
};
const getPortBindings = (boundPorts) => {
    const dockerodePortBindings = {};
    for (const [internalPort, hostPort] of boundPorts.iterator()) {
        dockerodePortBindings[internalPort.toString()] = [{ HostPort: hostPort.toString() }];
    }
    return dockerodePortBindings;
};
const getBindMounts = (bindMounts) => {
    return bindMounts.map(({ source, target, bindMode }) => `${source}:${target}:${bindMode}`);
};
const getHealthCheck = (healthCheck) => {
    if (healthCheck === undefined) {
        return undefined;
    }
    return {
        Test: ["CMD-SHELL", healthCheck.test],
        Interval: healthCheck.interval ? toNanos(healthCheck.interval) : 0,
        Timeout: healthCheck.timeout ? toNanos(healthCheck.timeout) : 0,
        Retries: healthCheck.retries || 0,
        StartPeriod: healthCheck.startPeriod ? toNanos(healthCheck.startPeriod) : 0,
    };
};
const toNanos = (duration) => duration * 1e6;
const getLogConfig = (useDefaultLogDriver) => {
    if (!useDefaultLogDriver) {
        return undefined;
    }
    return {
        Type: "json-file",
        Config: {},
    };
};
