"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createQueryTestCase = exports.QueryTestAbstract = exports.prepareCompiler = void 0;
// eslint-disable-next-line import/no-extraneous-dependencies
const globals_1 = require("@jest/globals");
const schema_compiler_1 = require("@cubejs-backend/schema-compiler");
const shared_1 = require("@cubejs-backend/shared");
const utils_1 = require("../utils");
const prepareCompiler = (content, options) => schema_compiler_1.prepareCompiler({
    localPath: () => __dirname,
    dataSchemaFiles: () => Promise.resolve([
        { fileName: 'main.js', content }
    ])
}, { adapter: 'postgres', ...options });
exports.prepareCompiler = prepareCompiler;
class QueryTestAbstract {
    getQuery(a, b) {
        const QueryClass = this.getQueryClass();
        return new QueryClass(a, b);
    }
    async testRefreshKeyEveryDay(connection) {
        const { compiler, joinGraph, cubeEvaluator } = exports.prepareCompiler(utils_1.createCubeSchema({
            name: 'cards',
            preAggregations: `
          countCreatedAt: {
              type: 'rollup',
              external: true,
              measureReferences: [count],
              timeDimensionReference: createdAt,
              granularity: \`day\`,
              partitionGranularity: \`month\`,
              scheduledRefresh: true,
              refreshKey: {
                every: \`1 day\`,
              },
          },
        `
        }));
        await compiler.compile();
        const query = this.getQuery({ joinGraph, cubeEvaluator, compiler }, {
            measures: [
                'cards.count'
            ],
            timeDimensions: [{
                    dimension: 'cards.createdAt',
                    granularity: 'day',
                    dateRange: ['2016-12-30', '2017-01-05']
                }],
            filters: [],
            timezone: 'America/Los_Angeles',
        });
        const preAggregations = query.newPreAggregations().preAggregationsDescription();
        const [sql, params] = preAggregations[0].invalidateKeyQueries[0];
        console.log('Executing ', [sql, params]);
        await connection.query(sql, params, {});
    }
    async testRefreshKeyIncrementalWithUpdateWindow(connection) {
        const { compiler, joinGraph, cubeEvaluator } = exports.prepareCompiler(utils_1.createCubeSchema({
            name: 'cards',
            preAggregations: `
          countCreatedAt: {
              type: 'rollup',
              external: true,
              measureReferences: [count],
              timeDimensionReference: createdAt,
              granularity: \`day\`,
              partitionGranularity: \`month\`,
              scheduledRefresh: true,
              refreshKey: {
                every: \`1 day\`,
                incremental: true,
                updateWindow: \`7 day\`,
              },
          },
        `
        }));
        await compiler.compile();
        const query = this.getQuery({ joinGraph, cubeEvaluator, compiler }, {
            measures: [
                'cards.count'
            ],
            timeDimensions: [{
                    dimension: 'cards.createdAt',
                    granularity: 'day',
                    dateRange: ['2016-12-30', '2017-01-05']
                }],
            filters: [],
            timezone: 'America/Los_Angeles',
        });
        const preAggregations = query.newPreAggregations().preAggregationsDescription();
        // eslint-disable-next-line prefer-const
        let [sql, params] = preAggregations[0].invalidateKeyQueries[0];
        // TODO Introduce full cycle testing through BaseDbRunner / QueryOrchestrator.
        // TODO Internal structures shouldn't be never accessed in tests.
        params = params.map((p) => (p === shared_1.TO_PARTITION_RANGE ? '2017-01-05T00:00:00' : p));
        console.log('Executing ', [sql, params]);
        await connection.query(sql, params, {});
    }
}
exports.QueryTestAbstract = QueryTestAbstract;
function createQueryTestCase(test, opts) {
    globals_1.describe(`${opts.name}Query`, () => {
        globals_1.jest.setTimeout(60 * 1000);
        let container;
        let connection;
        globals_1.beforeAll(async () => {
            container = await opts.DbRunnerClass.startContainer({});
            connection = opts.connectionFactory(container);
        });
        globals_1.afterAll(async () => {
            if (connection) {
                await connection.release();
            }
            if (container) {
                await container.stop();
            }
        });
        globals_1.it('test refreshKey every day', async () => test.testRefreshKeyEveryDay(connection));
        globals_1.it('test refreshKey incremental with update window', async () => test.testRefreshKeyIncrementalWithUpdateWindow(connection));
    });
}
exports.createQueryTestCase = createQueryTestCase;
//# sourceMappingURL=query-test.abstract.js.map